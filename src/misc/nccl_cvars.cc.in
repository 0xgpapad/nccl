// (c) Meta Platforms, Inc. and affiliates. Confidential and proprietary.

#include <sys/syscall.h>
#include <unistd.h>
#include <string>
#include <iostream>
#include <algorithm>
#include <unordered_set>
#include <vector>
#include <cstring>
#include "nccl_cvars.h"
#include "debug.h"
#include "checks.h"

/**
* Cvar template source file.
* It initializes control variables for NCCL at environment initialization time.
* Partial contents are auto-generated by ./maint/extractcvars.py
* See ## CONTENTS ## in nccl_cvars.cc.in
*/

#define CVAR_WARN_UNKNOWN_VALUE(name, value)               \
  do {                                                     \
    WARN("Unknown value %s for env %s", name, value);      \
  } while (0)

// trim from start (in place)
static inline void ltrim(std::string &s) {
  s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch) {
    return !std::isspace(ch);
  }));
}

// trim from end (in place)
static inline void rtrim(std::string &s) {
  s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
    return !std::isspace(ch);
  }).base(), s.end());
}

static std::vector<std::string> tokenizer(const char *str_, const char *def_) {
  const char *def = def_ ? def_ : "";
  std::string str(getenv(str_) ? getenv(str_) : def);
  std::string delim = ",";
  std::vector<std::string> tokens;

  while (auto pos = str.find(",")) {
    std::string newstr = str.substr(0, pos);
    ltrim(newstr);
    rtrim(newstr);
    // Skip empty string
    if(!newstr.empty()) {
      if(std::find(tokens.begin(), tokens.end(), newstr) != tokens.end()) {
        // WARN("Duplicate token %s found in the value of %s", newstr.c_str(), str_);
      }
      tokens.push_back(newstr);
    }
    str.erase(0, pos + delim.length());
    if (pos == std::string::npos) {
      break;
    }
  }
  return tokens;
}

static bool env2bool(const char *str_, const char *def) {
  std::string str(getenv(str_) ? getenv(str_) : def);
  std::transform(str.cbegin(), str.cend(), str.begin(), [](unsigned char c) { return std::tolower(c); });
  if (str == "y") return true;
  else if (str == "n") return false;
  else if (str == "yes") return true;
  else if (str == "no") return false;
  else if (str == "t") return true;
  else if (str == "f") return false;
  else if (str == "true") return true;
  else if (str == "false") return false;
  else if (str == "1") return true;
  else if (str == "0") return false;
  // else CVAR_WARN_UNKNOWN_VALUE(str_, str.c_str());
  return true;
}

static int env2int(const char *str, const char *def) {
  return getenv(str) ? atoi(getenv(str)) : atoi(def);
}

static std::string env2str(const char *str, const char *def_) {
  const char *def = def_ ? def_ : "";
  std::string str_s = getenv(str) ? std::string(getenv(str)) : std::string(def);
  ltrim(str_s);
  rtrim(str_s);
  return str_s;
}

static std::vector<std::string> env2strlist(const char *str, const char *def) {
  return tokenizer(str, def);
}

## NCCL_CVAR_STORAGE_DECL ##

extern char **environ;
static std::unordered_set<std::string> env;

## NCCL_CVAR_INIT_ENV_SET ##

## NCCL_CVAR_READ_CVAR_ENV ##

void ncclCvarInit() {
  initEnvSet();

  // Check if any NCCL_ env var is not in allow list
  char **s = environ;
  for (; *s; s++) {
    if (!strncmp(*s, "NCCL_", strlen("NCCL_"))) {
      std::string str(*s);
      str = str.substr(0, str.find("="));
      if (env.find(str) == env.end()) {
        // CVAR_WARN("Unknown env %s in the NCCL namespace\n", str.c_str());
      }
    }
  }

  readCvarEnv();
}
